#version 450 core
#extension GL_ARB_compute_shader:enable
#extension GL_ARB_shader_storage_buffer_object:enable

//change to vec4 data alligemnt !!
layout(location=0)uniform float dt;
layout(local_size_x=1024)in;

layout(std430,binding=0)buffer Pos
{
    vec4 positions[];// array of positions + isMoveable
};

/*
layout(std430,binding=1)buffer oldPos
{
    vec4 oldPositions[];// array of positions
};

layout(std430,binding=2)buffer acc
{
    vec4 accelerations[];// array of velocities
};

layout(std430,binding=3)buffer con
{
    vec4 constraint[];// array of constraints
    //p1 index
    //p2 index
    //rest distance
};

layout(std430,binding=4)buffer mov
{
    vec4 constraintPart2[];// array of contrains part 2
    //p1 moveable
    //p2 moveable
};

*/

void main()
{
    int N = int(gl_GlobalInvocationID);
   /* 
    int p1Index = int(constraint[N].x);
    int p2Index = int(constraint[N].y);
    float restDistance = constraint[N].z;
    
    bool p1Moveable = bool(constraintPart2[p1Index].x);
    bool p2Moveable = bool(constraintPart2[p2Index].y);
    
    vec3 p1_position = positions[p1Index].xyz;
    vec3 p1_acceleration = accelerations[p1Index].xyz;
    vec3 p2_position = positions[p2Index].xyz;
    vec3 p2_acceleration = accelerations[p2Index].xyz;
    
    //resolve contraints
    
    vec3 p1_to_p2=p2_position-p1_position;
    float current_distance=sqrt(p1_to_p2.x*p1_to_p2.x+
        p1_to_p2.y*p1_to_p2.y+
    p1_to_p2.z*p1_to_p2.z);
    
    vec3 correctionVector = p1_to_p2*(1-restDistance/current_distance);
    vec3 correctionVectorHalf = correctionVector*.5f;
    */
   // if(p1Moveable)
   // {
   //     positions[p1Index] = vec4(0);// += vec4(correctionVectorHalf,p1Moveable);
  //  }
   // if(p2Moveable)
   // {
       
        positions[N] += vec4(0,-0.01,0,0); //-= vec4(correctionVectorHalf,p2Moveable);
  //  }
    
}
